import { ChildProcess, execSync, spawn } from "child_process";
import { existsSync, mkdirSync, readFileSync, writeFileSync, rmSync, statSync } from "fs";
import { join } from "path";
import { SpawnFunctionAgentsParamsSchema } from "@objectiveai/function-agent";

// Track all spawned child processes for cleanup
const childProcesses: ChildProcess[] = [];

// Progress tracking
let totalAgents = 0;
let finishedAgents = 0;

function killAllChildren(): void {
  for (const child of childProcesses) {
    if (!child.killed && child.pid) {
      try {
        process.kill(child.pid);
      } catch {}
    }
  }
}

// Register cleanup handlers to prevent orphan processes
process.on("exit", killAllChildren);
process.on("SIGINT", () => {
  killAllChildren();
  process.exit(130);
});
process.on("SIGTERM", () => {
  killAllChildren();
  process.exit(143);
});
process.on("uncaughtException", (err) => {
  killAllChildren();
  throw err;
});
process.on("unhandledRejection", (err) => {
  killAllChildren();
  throw err;
});

interface AgentResult {
  owner: string;
  repository: string;
  commit: string;
}

interface AgentError {
  error: string;
}

type Result = AgentResult | AgentError;

// Read JSON file that should contain a string value
// Handles both quoted ("value") and unquoted (value) content
function readStringJsonFile(path: string): string | null {
  if (!existsSync(path)) {
    return null;
  }
  let content = readFileSync(path, "utf-8").trim();
  if (!content || content === "null") {
    return null;
  }
  if (content.startsWith('"') && content.endsWith('"')) {
    content = content.slice(1, -1);
  }
  return content;
}

// Read current depth from parameters.json
function getCurrentDepth(): number {
  if (!existsSync("parameters.json")) {
    return 0;
  }
  const content = readFileSync("parameters.json", "utf-8");
  const params = JSON.parse(content) as { depth: number };
  return params.depth ?? 0;
}

async function runAgentInSubdir(name: string, spec: string, childDepth: number): Promise<Result> {
  const subdir = join("agent_functions", name);

  // Create subdirectory
  mkdirSync(subdir, { recursive: true });

  // Write a runner script that will be executed in the subdirectory
  const runnerScript = `
import { Claude } from "@objectiveai/function-agent";

async function main(): Promise<void> {
  await Claude.invent({ name: ${JSON.stringify(name)}, spec: ${JSON.stringify(spec)}, depth: ${childDepth} });
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
`;

  const runnerPath = join(subdir, "_runner.ts");
  writeFileSync(runnerPath, runnerScript);

  return new Promise<Result>((resolve) => {
    const child = spawn("npx", ["ts-node", "_runner.ts"], {
      cwd: subdir,
      stdio: ["inherit", "pipe", "pipe"],
      shell: true,
    });

    // Track child process for cleanup
    childProcesses.push(child);

    // Capture but discard output to avoid context overload in parent
    child.stdout?.on("data", () => {});
    child.stderr?.on("data", () => {});

    child.on("close", (code) => {
      finishedAgents++;
      if (code !== 0) {
        resolve({ error: `Agent exited with code ${code}. See ${subdir}/logs/ for details.` });
        return;
      }

      // Extract owner/repo/commit from the completed function
      try {
        const nameJsonPath = join(subdir, "github", "name.json");
        const fnName = readStringJsonFile(nameJsonPath);

        // Get owner from git remote
        const remote = execSync("git remote get-url origin", {
          cwd: subdir,
          encoding: "utf-8",
        }).trim();

        // Parse owner from remote URL (https://github.com/owner/repo or git@github.com:owner/repo)
        const match = remote.match(/github\.com[:/]([^/]+)\/([^/.]+)/);
        const owner = match?.[1] ?? "unknown";
        const repository = match?.[2] ?? fnName ?? name;

        // Get latest commit
        const commit = execSync("git rev-parse HEAD", {
          cwd: subdir,
          encoding: "utf-8",
        }).trim();

        resolve({ owner, repository, commit });
      } catch (err) {
        resolve({ error: `Failed to extract result: ${err}` });
      }
    });

    child.on("error", (err) => {
      finishedAgents++;
      resolve({ error: `Failed to spawn agent: ${err.message}` });
    });
  });
}

async function main(): Promise<void> {
  // Read params from file
  if (!existsSync("spawnFunctionAgentsParams.json")) {
    console.error("spawnFunctionAgentsParams.json not found. Write it first.");
    process.exit(1);
  }

  const raw = JSON.parse(readFileSync("spawnFunctionAgentsParams.json", "utf-8"));
  const params = SpawnFunctionAgentsParamsSchema.parse(raw);

  if (params.length === 0) {
    console.error("spawnFunctionAgentsParams.json is empty.");
    process.exit(1);
  }

  // Check for duplicate names
  const names = params.map((p) => p.name);
  const duplicates = names.filter((n, i) => names.indexOf(n) !== i);
  if (duplicates.length > 0) {
    console.error(`Duplicate names in params: ${[...new Set(duplicates)].join(", ")}`);
    process.exit(1);
  }

  // Process overwrites first - delete existing directories
  for (const param of params) {
    const dir = join("agent_functions", param.name);
    if (param.overwrite && existsSync(dir)) {
      console.log(`Overwriting: deleting ${dir}...`);
      try {
        rmSync(dir, { recursive: true, force: true });
      } catch (err) {
        console.error(
          `Failed to delete ${dir}: ${err}. If this error persists, make a new function with a different name instead.`,
        );
        process.exit(1);
      }
    }
  }

  // Check for existing directories (after overwrites)
  for (const param of params) {
    const dir = join("agent_functions", param.name);
    if (existsSync(dir) && statSync(dir).isDirectory()) {
      console.error(
        `agent_functions/${param.name} already exists. Set "overwrite": true to replace it, or use a different name.`,
      );
      process.exit(1);
    }
  }

  // Calculate child depth (current depth - 1)
  const currentDepth = getCurrentDepth();
  const childDepth = Math.max(0, currentDepth - 1);

  console.log(`Spawning ${params.length} function agents with depth=${childDepth}...`);

  // Count agents for progress tracking
  totalAgents = params.length;

  // Start progress reporting every 60 seconds
  const progressInterval = setInterval(() => {
    const running = totalAgents - finishedAgents;
    console.log(`[Progress] ${running}/${totalAgents} agents running, ${finishedAgents}/${totalAgents} agents finished`);
  }, 60000);

  // Run all agents in parallel
  const results = await Promise.all(
    params.map((param) => runAgentInSubdir(param.name, param.spec, childDepth))
  );

  // Stop progress reporting
  clearInterval(progressInterval);

  // Build output with names
  const output = params.map((param, i) => ({
    name: param.name,
    ...results[i],
  }));

  // Output results as JSON
  console.log("\n=== SPAWN_RESULTS ===");
  console.log(JSON.stringify(output, null, 2));
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
