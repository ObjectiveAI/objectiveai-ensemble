"use client";

import { useRef, useMemo, useEffect } from "react";
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";

// =============================================================================
// THINKER FIGURE — Loads GLB model generated by scripts/generate-thinker.py
// =============================================================================
// Each figure = one LLM in the ensemble. Size = weight (influence).
// Model hierarchy (from Blender):
//   Thinker (root)
//     Body        — continuous mesh (torso + tapered legs, seamless)
//     HeadPivot   — empty at neck joint (drives head tilt)
//       Head      — rounded rectangular box
//       EyeL/EyeR — dark inset spheres
//       Shell     — translucent dome (head-only)
// =============================================================================

const MODEL_PATH = "/models/thinker.glb";

/** Configuration object for a single Thinker figure */
export interface ThinkerConfig {
  /** Scale multiplier (1 = base size). Maps to ensemble weight. */
  scale: number;
  /** Head tilt in radians (X rotation) — negative = downward nod */
  headTilt: number;
  /** Shell coverage: 0 = hidden, >0 = visible */
  shellCoverage: number;
  /** Shell purple tint intensity [0-1] */
  shellTint: number;
  /** Position in the scene */
  position: [number, number, number];
  /** Y-axis rotation of the whole figure (face toward center) */
  rotationY: number;
}

/** Default config for the base archetype */
export const DEFAULT_CONFIG: ThinkerConfig = {
  scale: 1,
  headTilt: 0,
  shellCoverage: 0.8,
  shellTint: 0.3,
  position: [0, 0, 0],
  rotationY: 0,
};

export default function ThinkerFigure({
  config = DEFAULT_CONFIG,
}: {
  config?: ThinkerConfig;
}) {
  const groupRef = useRef<THREE.Group>(null);
  const { scene } = useGLTF(MODEL_PATH);

  // ---- Materials (defined in code for precise WebGL control) ----

  const bodyMat = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: "#EDEDF2",
        roughness: 0.25,
        metalness: 0.05,
      }),
    []
  );

  const eyeMat = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        color: "#2a2a2a",
        roughness: 0.6,
        metalness: 0,
      }),
    []
  );

  const shellMat = useMemo(
    () =>
      new THREE.MeshPhysicalMaterial({
        color: new THREE.Color("#6B5CFF").multiplyScalar(config.shellTint),
        transparent: true,
        opacity: 0.15,
        roughness: 0.1,
        metalness: 0,
        transmission: 0.8,
        thickness: 0.5,
        ior: 1.45,
        clearcoat: 1,
        clearcoatRoughness: 0.05,
        side: THREE.DoubleSide,
      }),
    [config.shellTint]
  );

  // ---- Clone scene per instance (shared geometry, independent transforms) ----

  const model = useMemo(() => {
    const clone = scene.clone(true);
    clone.traverse((child) => {
      if (!(child instanceof THREE.Mesh)) return;
      switch (child.name) {
        case "Body":
        case "Head":
          child.material = bodyMat;
          break;
        case "EyeL":
        case "EyeR":
          child.material = eyeMat;
          break;
        case "Shell":
          child.material = shellMat;
          break;
      }
    });
    return clone;
  }, [scene, bodyMat, eyeMat, shellMat]);

  // ---- Cleanup GPU resources on unmount ----

  useEffect(() => {
    return () => {
      bodyMat.dispose();
      eyeMat.dispose();
      shellMat.dispose();
    };
  }, [bodyMat, eyeMat, shellMat]);

  // ---- Per-frame updates ----

  useFrame((state) => {
    if (!groupRef.current) return;

    // Ambient float — slow meditative drift
    const t = state.clock.elapsedTime;
    groupRef.current.position.y =
      config.position[1] + Math.sin(t * 0.5 + config.position[0]) * 0.03;

    // Head tilt (driven by config, applied to HeadPivot empty)
    const pivot = model.getObjectByName("HeadPivot");
    if (pivot) pivot.rotation.x = config.headTilt;

    // Shell visibility
    const shell = model.getObjectByName("Shell");
    if (shell) shell.visible = config.shellCoverage > 0;
  });

  return (
    <group
      ref={groupRef}
      position={config.position}
      rotation={[0, config.rotationY, 0]}
      scale={config.scale}
    >
      <primitive object={model} />
    </group>
  );
}

useGLTF.preload(MODEL_PATH);
