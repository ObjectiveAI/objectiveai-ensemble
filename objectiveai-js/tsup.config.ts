import { defineConfig, Options } from "tsup";
import path from "path";
import type { Plugin } from "esbuild";

// Create a plugin that rewrites #wasm-loader imports based on format
function createWasmLoaderPlugin(format: "cjs" | "esm"): Plugin {
  const loaderExt = format === "cjs" ? ".cjs" : ".js";

  return {
    name: "wasm-loader-rewriter",
    setup(build) {
      // Intercept #wasm-loader imports and rewrite to runtime path
      build.onResolve({ filter: /^#wasm-loader$/ }, (args) => {
        return {
          path: `./wasm/loader${loaderExt}`,
          external: true,
        };
      });
    },
  };
}

// Generate separate config for each format so we can use format-specific plugins
const baseConfig: Options = {
  entry: ["src/index.ts"],
  dts: true,
  outDir: "dist",
  clean: true,
  treeshake: true,
  target: "es2022",
  esbuildOptions(options) {
    options.alias = {
      src: path.resolve(__dirname, "src"),
    };
  },
};

export default defineConfig([
  {
    ...baseConfig,
    format: ["esm"],
    esbuildPlugins: [createWasmLoaderPlugin("esm")],
    esbuildOptions(options) {
      options.alias = {
        src: path.resolve(__dirname, "src"),
      };
    },
    outExtension: () => ({ js: ".js" }),
    clean: true, // Only clean on first build
  },
  {
    ...baseConfig,
    format: ["cjs"],
    esbuildPlugins: [createWasmLoaderPlugin("cjs")],
    esbuildOptions(options) {
      options.alias = {
        src: path.resolve(__dirname, "src"),
      };
    },
    outExtension: () => ({ js: ".cjs" }),
    clean: false, // Don't clean, ESM build already ran
    dts: false, // DTS already generated by ESM build
    // Copy wasm files to dist after this build completes
    async onSuccess() {
      const { cpSync } = await import("fs");
      const srcWasm = path.resolve(__dirname, "src", "wasm");
      const distWasm = path.resolve(__dirname, "dist", "wasm");
      cpSync(srcWasm, distWasm, { recursive: true });
      console.log("âœ“ Copied wasm files to dist/wasm/");
    },
  },
]);
