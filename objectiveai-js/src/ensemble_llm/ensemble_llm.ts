import z from "zod";
import { OutputModeSchema } from "./output_mode";
import { MessagesSchema } from "src/chat/completions/request/message";
import { StopSchema } from "./stop";
import { ProviderSchema } from "./provider";
import { ReasoningSchema } from "./reasoning";
import { VerbositySchema } from "./verbosity";

export const EnsembleLlmBaseSchema = z
  .object({
    model: z.string().describe("The full ID of the LLM to use."),
    output_mode: OutputModeSchema,
    synthetic_reasoning: z
      .boolean()
      .optional()
      .nullable()
      .describe(
        "For Vector Completions only, whether to use synthetic reasoning prior to voting. Works for any LLM, even those that do not have native reasoning capabilities."
      ),
    top_logprobs: z
      .int()
      .min(0)
      .max(20)
      .optional()
      .nullable()
      .describe(
        "For Vector Completions only, whether to use logprobs to make the vote probabilistic. This means that the LLM can vote for multiple keys based on their logprobabilities. Allows LLMs to express native uncertainty when voting."
      ),
    prefix_messages: MessagesSchema.optional()
      .nullable()
      .describe(
        `${MessagesSchema.description} These will be prepended to every prompt sent to this LLM. Useful for setting context or influencing behavior.`
      ),
    suffix_messages: MessagesSchema.optional()
      .nullable()
      .describe(
        `${MessagesSchema.description} These will be appended to every prompt sent to this LLM. Useful for setting context or influencing behavior.`
      ),
    frequency_penalty: z
      .number()
      .min(-2.0)
      .max(2.0)
      .optional()
      .nullable()
      .describe(
        "This setting aims to control the repetition of tokens based on how often they appear in the input. It tries to use less frequently those tokens that appear more in the input, proportional to how frequently they occur. Token penalty scales with the number of occurrences. Negative values will encourage token reuse."
      ),
    logit_bias: z
      .record(z.string(), z.int().min(-100).max(100))
      .optional()
      .nullable()
      .describe(
        "Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token."
      ),
    max_completion_tokens: z
      .int()
      .min(0)
      .max(2147483647)
      .optional()
      .nullable()
      .describe(
        "An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens."
      ),
    presence_penalty: z
      .number()
      .min(-2.0)
      .max(2.0)
      .optional()
      .nullable()
      .describe(
        "This setting aims to control the presence of tokens in the output. It tries to encourage the model to use tokens that are less present in the input, proportional to their presence in the input. Token presence scales with the number of occurrences. Negative values will encourage more diverse token usage."
      ),
    stop: StopSchema.optional().nullable(),
    temperature: z
      .number()
      .min(0.0)
      .max(2.0)
      .optional()
      .nullable()
      .describe(
        "This setting influences the variety in the model’s responses. Lower values lead to more predictable and typical responses, while higher values encourage more diverse and less common responses. At 0, the model always gives the same response for a given input."
      ),
    top_p: z
      .number()
      .min(0.0)
      .max(1.0)
      .optional()
      .nullable()
      .describe(
        "This setting limits the model’s choices to a percentage of likely tokens: only the top tokens whose probabilities add up to P. A lower value makes the model’s responses more predictable, while the default setting allows for a full range of token choices. Think of it like a dynamic Top-K."
      ),
    max_tokens: z
      .int()
      .min(0)
      .max(2147483647)
      .optional()
      .nullable()
      .describe(
        "This sets the upper limit for the number of tokens the model can generate in response. It won’t produce more than this limit. The maximum value is the context length minus the prompt length."
      ),
    min_p: z
      .number()
      .min(0.0)
      .max(1.0)
      .optional()
      .nullable()
      .describe(
        "Represents the minimum probability for a token to be considered, relative to the probability of the most likely token. (The value changes depending on the confidence level of the most probable token.) If your Min-P is set to 0.1, that means it will only allow for tokens that are at least 1/10th as probable as the best possible option."
      ),
    provider: ProviderSchema.optional().nullable(),
    reasoning: ReasoningSchema.optional().nullable(),
    repetition_penalty: z
      .number()
      .min(0.0)
      .max(2.0)
      .optional()
      .nullable()
      .describe(
        "Helps to reduce the repetition of tokens from the input. A higher value makes the model less likely to repeat tokens, but too high a value can make the output less coherent (often with run-on sentences that lack small words). Token penalty scales based on original token’s probability."
      ),
    top_a: z
      .number()
      .min(0.0)
      .max(1.0)
      .optional()
      .nullable()
      .describe(
        "Consider only the top tokens with “sufficiently high” probabilities based on the probability of the most likely token. Think of it like a dynamic Top-P. A lower Top-A value focuses the choices based on the highest probability token but with a narrower scope. A higher Top-A value does not necessarily affect the creativity of the output, but rather refines the filtering process based on the maximum probability."
      ),
    top_k: z
      .int()
      .min(0)
      .max(2147483647)
      .optional()
      .nullable()
      .describe(
        "This limits the model’s choice of tokens at each step, making it choose from a smaller set. A value of 1 means the model will always pick the most likely next token, leading to predictable results. By default this setting is disabled, making the model to consider all choices."
      ),
    verbosity: VerbositySchema.optional().nullable(),
  })
  .describe(
    "An LLM to be used within an Ensemble or standalone with Chat Completions."
  )
  .meta({ title: "EnsembleLlmBase" });
export type EnsembleLlmBase = z.infer<typeof EnsembleLlmBaseSchema>;

export const EnsembleLlmBaseWithFallbacksAndCountSchema =
  EnsembleLlmBaseSchema.extend({
    count: z
      .uint32()
      .min(1)
      .optional()
      .nullable()
      .describe(
        "A count greater than one effectively means that there are multiple instances of this LLM in an ensemble."
      ),
    fallbacks: z
      .array(EnsembleLlmBaseSchema)
      .optional()
      .nullable()
      .describe("A list of fallback LLMs to use if the primary LLM fails."),
  })
    .describe(
      "An LLM to be used within an Ensemble, including optional fallbacks and count."
    )
    .meta({ title: "EnsembleLlmBaseWithFallbacksAndCount" });
export type EnsembleLlmBaseWithFallbacksAndCount = z.infer<
  typeof EnsembleLlmBaseWithFallbacksAndCountSchema
>;

export const EnsembleLlmSchema = EnsembleLlmBaseSchema.extend({
  id: z.string().describe("The unique identifier for the Ensemble LLM."),
})
  .describe(
    "An LLM to be used within an Ensemble or standalone with Chat Completions, including its unique identifier."
  )
  .meta({ title: "EnsembleLlm" });
export type EnsembleLlm = z.infer<typeof EnsembleLlmSchema>;

export const EnsembleLlmWithFallbacksAndCountSchema = EnsembleLlmSchema.extend({
  count: EnsembleLlmBaseWithFallbacksAndCountSchema.shape.count,
  fallbacks: z
    .array(EnsembleLlmSchema)
    .optional()
    .nullable()
    .describe(
      EnsembleLlmBaseWithFallbacksAndCountSchema.shape.fallbacks.description!
    ),
})
  .describe(
    "An LLM to be used within an Ensemble, including its unique identifier, optional fallbacks, and count."
  )
  .meta({ title: "EnsembleLlmWithFallbacksAndCount" });
export type EnsembleLlmWithFallbacksAndCount = z.infer<
  typeof EnsembleLlmWithFallbacksAndCountSchema
>;
