import type { Plugin } from "esbuild";
import * as fs from "fs";
import * as path from "path";

/**
 * esbuild plugin that replaces convert() calls with pre-computed JSON Schema objects.
 * Reads from .schema-cache.json generated by precompute-schemas.ts.
 */
export function inlineConvertPlugin(): Plugin {
  const srcDir = path.resolve(__dirname, "../src");
  const cachePath = path.resolve(__dirname, "../.schema-cache.json");

  return {
    name: "inline-convert",
    setup(build) {
      // Load the pre-computed cache
      let cache: Record<string, any> = {};
      try {
        cache = JSON.parse(fs.readFileSync(cachePath, "utf8"));
      } catch {
        console.warn(
          "Warning: .schema-cache.json not found. Run `npx tsx scripts/precompute-schemas.ts` first.",
        );
        return;
      }

      // Index by file path for fast lookup
      const byFile = new Map<string, Map<string, any>>();
      for (const [key, value] of Object.entries(cache)) {
        const [file, schemaName] = key.split(":");
        if (!byFile.has(file)) byFile.set(file, new Map());
        byFile.get(file)!.set(schemaName, value);
      }

      build.onLoad({ filter: /\.ts$/ }, async (args) => {
        const relPath = path
          .relative(srcDir, args.path)
          .replace(/\\/g, "/");
        const fileSchemas = byFile.get(relPath);
        if (!fileSchemas) return null;

        let source = await fs.promises.readFile(args.path, "utf8");
        let modified = false;

        for (const [jsonSchemaName, value] of fileSchemas) {
          // Replace: export const XyzJsonSchema: JSONSchema = convert(SomeSchema);
          const pattern = new RegExp(
            `(export const ${jsonSchemaName}): JSONSchema =\\s*convert\\(\\s*\\w+\\s*,?\\s*\\);?`,
            "s",
          );
          if (pattern.test(source)) {
            source = source.replace(
              pattern,
              `$1 = ${JSON.stringify(value)};`,
            );
            modified = true;
          }
        }

        if (!modified) return null;

        // Remove unused convert import if no convert() calls remain
        if (!/\bconvert\(/.test(source)) {
          // Remove convert from import, keep type JSONSchema
          source = source.replace(
            /import\s*\{\s*convert\s*,\s*type\s+JSONSchema\s*\}\s*from\s*["'][^"']+["'];?\n?/g,
            "",
          );
          // Also handle if JSONSchema type is no longer needed
          // (keep it since it's used in the type annotation)
        }

        return { contents: source, loader: "ts" };
      });
    },
  };
}
